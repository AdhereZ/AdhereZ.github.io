(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{338:function(t,v,_){"use strict";_.r(v);var a=_(3),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http-1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" HTTP/1.0")]),t._v(" "),v("ul",[v("li",[t._v("无状态：服务器不跟踪不记录请求过的状态")]),t._v(" "),v("li",[t._v("无连接：浏览器每次请求都需要建立tcp连接")])]),t._v(" "),v("p",[t._v("浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立马断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态），这种无状态性可以借助"),v("code",[t._v("cookie/session")]),t._v("机制来做身份认证和状态记录。")]),t._v(" "),v("h2",{attrs:{id:"无连接导致缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#无连接导致缺点"}},[t._v("#")]),t._v(" 无连接导致缺点")]),t._v(" "),v("ol",[v("li",[t._v("无法复用连接，每次发送请求都需要进行一次TCP连接释放，这导致网络利用率低")]),t._v(" "),v("li",[t._v("队头阻塞。由于"),v("code",[t._v("HTTP/1.0")]),t._v("规定下一个请求在前一个响应到达前不能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，导致阻塞后面的请求")])]),t._v(" "),v("br"),t._v(" "),v("h1",{attrs:{id:"http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),v("ol",[v("li",[t._v("在缓存方面，"),v("code",[t._v("http1.0")]),t._v("只能使用"),v("code",[t._v("expires")]),t._v("，"),v("code",[t._v("if-modified-since")]),t._v("来进行缓存判断，http1.1则增加了"),v("code",[t._v("cache-control")]),t._v("，"),v("code",[t._v("e-tag")]),t._v("，"),v("code",[t._v("if-none-match")]),t._v("等更多缓存头来控制缓存")]),t._v(" "),v("li",[t._v("优化了带宽利用，"),v("code",[t._v("http1.0")]),t._v("客户端可能只需要某个对象的一部分，而服务端则将整个对象送过来了，到了"),v("code",[t._v("http1.1")]),t._v("，请求头引入了"),v("code",[t._v("range")]),t._v("头域，它允许只请求资源的某个部分，即返回码是206。")]),t._v(" "),v("li",[t._v("错误通知的管理，http1.1中新增了24个错误状态响应码，如"),v("code",[t._v("409（Conflict）")]),t._v("表示请求的资源与资源的当前状态发生冲突；"),v("code",[t._v("410（Gone）")]),t._v("表示服务器上的某个资源被永久性的删除。")]),t._v(" "),v("li",[v("strong",[t._v("Host头处理")]),t._v("，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。")]),t._v(" "),v("li",[t._v("长连接，http1.1中默认开启"),v("code",[t._v("Connection：keep-alive")]),t._v("，可以在同一条tcp连接上进行多个请求和响应，减少了每次请求都建立和关闭连接的消耗和延迟")])]),t._v(" "),v("br"),t._v(" "),v("h1",{attrs:{id:"http-2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" HTTP/2.0")]),t._v(" "),v("p",[t._v("前面说到的http1.1还是有些缺点：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("队头阻塞：tcp上发的请求得等前一个请求响应返回了，下一个请求才能发出去，后续的请求都得排队等候，虽然http1.1管线化可以支持请求并发，这个请求并发确实依赖于创建多个tcp连接，成本很高，浏览器很难实现")])]),t._v(" "),v("li",[v("p",[t._v("HTTP/1.X版本是采用文本格式，首部未压缩，http1.1的header带有大量信息，每次都要重复发送")])])]),t._v(" "),v("h2",{attrs:{id:"二进制分帧层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧层"}},[t._v("#")]),t._v(" 二进制分帧层")]),t._v(" "),v("p",[t._v("HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b7344d17ddb49138dfe477cca4a3baa~tplv-k3u1fbpfcp-zoom-1.image",alt:"image-20220519225226448"}})]),t._v(" "),v("p",[t._v("1.1响应是文本格式，而2.0把响应划分成了两个帧，图中的HEADERS（首部）和DATA（消息负载） 是帧的类型。也就是说一条HTTP响应，划分成了两个帧来传输，并且采用二进制来编码。")]),t._v(" "),v("p",[t._v("这里我们来提三个概念。")]),t._v(" "),v("ul",[v("li",[t._v("流（Stream）：已建立的TCP连接上的双向字节流，可以承载一个或多个消息。")]),t._v(" "),v("li",[t._v("消息（Message）：一个完整的HTTP请求或响应，由一个或多个帧组成。特定消息的帧在同一个流上发送，这意味着一个HTTP请求或响应只能在一个流上发送。")]),t._v(" "),v("li",[t._v("帧（Frame）：通信的基本单位。")])]),t._v(" "),v("p",[t._v("一个TCP连接上可以有任意数量的流。")]),t._v(" "),v("h2",{attrs:{id:"多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),v("p",[t._v("上面提到HTTP/1.1的线头阻塞和多个TCP连接的问题，HTTP2的多路复用完美解决。多路复用是这样实现多路复用的：http2.0创建一个tcp连接，一个连接上面可以有任意多个流，消息分割成一个或多个帧在流里面，帧传输过去后再进行重组，形成一个完整的请求或响应。但是还是会有请求排队的情况，因为服务器的处理请求的能力不是无止境的，流控制会管理数据的传输，当请求太多时，它会减少或停止请求的发送，免得接收方不堪重负")]),t._v(" "),v("h2",{attrs:{id:"头部压缩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),v("p",[t._v("在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销，现在一个网站上百个请求已经是常态了，每个请求的头部的一些字段都是相同的，例如cookie，user-agent等，所以http2.0会用HPACK压缩格式来压缩头部，头部压缩需要在浏览器和服务器端之间：")]),t._v(" "),v("ul",[v("li",[t._v("维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合")]),t._v(" "),v("li",[t._v("维护一份相同的动态字典，可以动态的添加内容")]),t._v(" "),v("li",[t._v("通过静态Huffman编码对传输的首部字段进行编码")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0da93b026043c0a5d757b32c6b1716~tplv-k3u1fbpfcp-zoom-1.image",alt:"image-20220519232128631"}})]),t._v(" "),v("p",[t._v("所以我们在传输首部字段的时候，例如要传输method:GET,那我们只需要传输静态字典里面method:GET对应的索引值就可以了，一个字节搞定。")]),t._v(" "),v("p",[t._v("像user-agent、cookie这种静态字典里面只有首部名称而没有值的首部，第一次传输需要user-agent在静态字典中的索引以及他的值，值会采用静态Huffman编码来减小体积。第一次传输过user-agent 之后呢，浏览器和服务器端就会把它添加到自己的动态字典中。后续传输就可以传输索引了，一个字节搞定。")]),t._v(" "),v("h2",{attrs:{id:"服务器端推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器端推送"}},[t._v("#")]),t._v(" 服务器端推送")]),t._v(" "),v("p",[t._v("服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。")]),t._v(" "),v("p",[t._v("例如：客户端请求index.html，服务器端能够额外推送script.js和style.css。 实现原理就是客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存，当客户端收到原始网页的请求时，它需要的资源已经位于缓存。")]),t._v(" "),v("br"),t._v(" "),v("h1",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("h2",{attrs:{id:"http-1-0-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-2"}},[t._v("#")]),t._v(" HTTP 1.0")]),t._v(" "),v("ul",[v("li",[t._v("无状态")]),t._v(" "),v("li",[t._v("无连接")])]),t._v(" "),v("h2",{attrs:{id:"http-1-1-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-2"}},[t._v("#")]),t._v(" HTTP 1.1")]),t._v(" "),v("ul",[v("li",[t._v("长连接")]),t._v(" "),v("li",[t._v("增加缓存处理（cache-control，e-tag，If-none-match等）")]),t._v(" "),v("li",[t._v("增加host头域")]),t._v(" "),v("li",[t._v("增加range头域，支持断点重传，不用一整个对象返回，只返回需要的部分，返回206")]),t._v(" "),v("li",[t._v("新增错误响应状态码")])]),t._v(" "),v("h2",{attrs:{id:"http-2-0-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0-2"}},[t._v("#")]),t._v(" HTTP 2.0")]),t._v(" "),v("ul",[v("li",[t._v("二进制分帧")]),t._v(" "),v("li",[t._v("多路复用")]),t._v(" "),v("li",[t._v("头部压缩")]),t._v(" "),v("li",[t._v("服务器端推送")])]),t._v(" "),v("br"),t._v(" "),v("h1",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903734670000142",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试官问：你了解HTTP2.0吗？"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844903489596833800",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP1.0、HTTP1.1 和 HTTP2.0 的区别"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000013028798",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);